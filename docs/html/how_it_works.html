







<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>How it Works | docs</title>
    <link rel="shortcut icon" href="_static/favicon.ico">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css">
    <link rel="stylesheet" href="_static/theme.css" type="text/css">
    
      
    <link rel="stylesheet" type="text/css" href="_static/css/miros_docs.css" />
      
    
    

    
    <script type="text/javascript" src="_static/theme.js" defer></script>
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    
    <script src="_static/jquery.js"></script>
    
    <script src="_static/underscore.js"></script>
    
    <script src="_static/doctools.js"></script>
    
    <script src="_static/language_data.js"></script>
    
    

    
      
      
    <link rel="index" title="Index" href="genindex.html">
      
      
    <link rel="search" title="Search" href="search.html">
      
      
      
    <link rel="next" title="Example" href="example.html">
      
      
    <link rel="prev" title="Quick Start" href="quick_start.html">
      
    

    

    

    
  </head>

  <body>
    <header class="main-header">
      <div class="navbar">
        <div id="js-sidebar-mask" class="sidebar-mask"></div>
        <div id="js-sidebar-menu-button" class="sidebar-menu-button">
          <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg>
        </div>
        <a href="index.html" class="site-link">
          
          miros rabbit-mq
          
        </a>
        <div class="navbar-links">
          <a href="introduction.html" class="navbar-link">Docs</a>
          
          <a href="https://github.com/aleph2c/miros-rabbitmq" class="navbar-link">GitHub</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg>
          
        </div>
      </div>
    </header>

    <main class="main-wrapper">
      
      <div id="js-main-sidebar" class="main-sidebar">
        
        <div class="sidebar-content sidebar-content--divider sidebar-navbar-links">
          <a href="https://github.com/aleph2c/miros-rabbitmq" class="sidebar-navbar-link">GitHub</a>
          <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg>
        </div>
        
        
        <div class="sidebar-content sidebar-logo">
    <a href="index.html">
      <img class="logo" src="_static/miros_rabbitmq_logo_v2.svg" alt="miros" >
    </a>
</div>
        
        

<h2 class="sidebar-heading">Contents</h2>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing_infrastructure.html">DevOps</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="quick_start.html">Quick Start</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">How it Works</a></li>
<li class="toctree-l1"><a class="reference internal" href="example.html">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="recipes.html">Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="reflection.html">Reflection</a></li>
<li class="toctree-l1"><a class="reference internal" href="docs.html">Documenting</a></li>
<li class="toctree-l1"><a class="reference internal" href="deployment.html">Deployment</a></li>
</ul>

        
        <h3 class="sidebar-heading">About</h3>
<p class="sidebar-content">
  A networking plugin for miros
</p>
<h3 class="sidebar-heading">Useful Links</h3>
<ul>
  <li><a href="https://github.com/aleph2c/miros-rabbitmq">miros-rabbitmq on Github</a></li>
  <li><a href="https://aleph2c.github.io/miros/index.html">miros</a></li>
  <li><a href="https://github.com/aleph2c/miros">miros on Github</a></li>
  <li><a href="https://github.com/aleph2c/sequence">sequence on Github</a></li>
  <li><a href="http://www.umlet.com">UMLet (drawing tool)</a></li>
</ul>

<h3 class="sidebar-heading">Tutorials</h3>
<ul>
  <li><a href="https://www.rabbitmq.com/tutorials/tutorial-one-python.html">basics</a></li>
  <li><a href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html">work queues</a></li>
  <li><a href="https://www.rabbitmq.com/tutorials/tutorial-three-python.html">publish subscribe</a></li>
  <li><a href="https://www.rabbitmq.com/tutorials/tutorial-four-python.html">routing</a></li>
  <li><a href="https://www.rabbitmq.com/tutorials/tutorial-five-python.html">topics</a></li>
  <li><a href="https://www.rabbitmq.com/tutorials/tutorial-six-python.html">remote procedure calls (rpc)</a></li>
</ul>

<h3 class="sidebar-heading">Videos</h3>
<ul>
  <li><a href="https://www.youtube.com/watch?v=deG25y_r6OY">RabbitMQ in Five Minutes</a></li>
  <li><a href="https://www.youtube.com/watch?v=gKzKUmtOwR4">RabbitMQ Windows Install</a></li>
</ul>
        
        

<div id="searchbox" style="display: none" role="search">
  <h2 id="searchlabel" class="sidebar-heading">Quick search</h2>
  <div class="searchformwrapper sidebar-content">
    <form class="search" action="search.html" method="get">
      <input class="sidebar-search sidebar-search--input" type="text" name="q" aria-labelledby="searchlabel"><input class="sidebar-search sidebar-search--btn" type="submit" value="Go">
    </form>
  </div>
</div>
<script>$('#searchbox').show(0);</script>

        
      </div>
      

      
      <div class="main-content main-content--sidebar">
      
        
          
  <div class="section" id="how-it-works">
<span id="how-it-works-how-the-plugin-works"></span><h1>How it Works<a class="headerlink" href="#how-it-works" title="Permalink to this headline">#</a></h1>
<blockquote class="epigraph">
<div><p><em>The most contrarian thing of all is not to oppose the crowd but to think for
yourself.</em></p>
<p class="attribution">—Peter Thiel</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You don’t need to understand this page to use this library.  It has been added
to round out the documentation and to be a guide for writing other network
plugins for miros.  If a diagram is too small, click on it to see it’s pdf.
If you don’t have a lot of time, your time would be better spent looking at
the <a class="reference internal" href="example.html#example"><span class="std std-ref">next example</span></a>.</p>
</div>
<p>There are two main classes that you will use with miros to build statecharts,
the <a class="reference external" href="https://aleph2c.github.io/miros/singlechartexample.html">ActiveObject</a> and
the <a class="reference external" href="https://aleph2c.github.io/miros/towardsthefactoryexample.html#towardsthefactoryexample-using-the-factory-class">Factory</a>
class.  This plugin extends these two classes as the NetworkedActiveObject and
the NetworkedFactory class.</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_0.pdf"><img alt="_images/miros_rabbitmq_0.svg" class="noscale-center" src="_images/miros_rabbitmq_0.svg" /></a>
<p>To build a state chart you would follow all of the same <a class="reference external" href="https://aleph2c.github.io/miros/recipes.html">rules that you learned
before</a> and you would get some
additional networking features.</p>
<p>So, if you wanted to have networked statecharts you would install miros,
miros-rabbitmq and RabbitMQ.  If you wanted to build your statechart using <a class="reference external" href="https://aleph2c.github.io/miros/recipes.html#boiler-plate-state-method-code">flat
methods</a> you would use the NetworkedActiveObject class.  If you would rather
build it up using <a class="reference external" href="https://aleph2c.github.io/miros/recipes.html#creating-a-statechart-from-a-factory">callbacks</a> you would use the NetworkedFactory class.</p>
<p>Both of these networked classes share the same interface and communicate on the
same server infrastructure:  the miros-rabbitmq plugin builds up three topic
based AMPQ networks named the mesh, the snoop_trace and the snoop_spy.  Here is
a RabbitMQ style diagram of these networks.  If you don’t understand the diagram
it is explained in more details further down this page.</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_network_0.pdf"><img alt="_images/miros_rabbitmq_network_0.svg" class="scale-to-fit" src="_images/miros_rabbitmq_network_0.svg" /></a>
<p>The mesh network is used by the statecharts to send encrypted and serialized
events to one another.  The snoop_trace is used to share <a class="reference external" href="https://aleph2c.github.io/miros/recipes.html#using-the-trace">trace instrumentation</a>
output between all of the connected computers.  It provides the means to debug
your entire distributed system from one location.  The snoop_spy is like the
snoop_trace, but it shares the <a class="reference external" href="https://aleph2c.github.io/miros/recipes.html#using-the-spy">spy information</a> (a lot of information) between
all of your connected computers.  Each network can be configured with it’s own
encryption key.  The snoop_trace and snoop_spy networks can be enabled and
disabled independently, but the mesh is always on.</p>
<p>This plugin’s main methods are the <code class="docutils literal notranslate"><span class="pre">transmit</span></code>, <code class="docutils literal notranslate"><span class="pre">enable_snoop_trace</span></code>, and
<code class="docutils literal notranslate"><span class="pre">enable_snoop_spy</span></code>.  The NetworkedActiveObject and the NetworkedFactory share
the same interface.</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_1.pdf"><img alt="_images/miros_rabbitmq_1.svg" class="scale-to-fit" src="_images/miros_rabbitmq_1.svg" /></a>
<p>The <code class="docutils literal notranslate"><span class="pre">transmit</span></code> is used to send out an event to the mesh network.  When it is
received by another statechart, it’s event is place in it’s FIFO queue for
processing.   The statechart receiving such an event, has no notion that the
event came from another machine.  If it has been designed to respond to the
event it will.</p>
<p>The NetworkedActiveObject and NetworkedFactory require more information in their
constructors than do the ActiveObject and the Factory.  This information
describes the credentials required to connect to the RabbitMQ server and the
encryption key(s) for the three different networks.</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_2.pdf"><img alt="_images/miros_rabbitmq_2.svg" class="scale-to-fit" src="_images/miros_rabbitmq_2.svg" /></a>
<p>The snoop_trace and snoop_spy networks will use the <code class="docutils literal notranslate"><span class="pre">mesh_encryption_key</span></code> if a
<code class="docutils literal notranslate"><span class="pre">snoop_trace_encryption_key</span></code> or a <code class="docutils literal notranslate"><span class="pre">snoop_spy_encryption_key</span></code> are not
provided.</p>
<p>The NetworkedActiveObject and NetworkedFactory have a MirosNets object.</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_3.pdf"><img alt="_images/miros_rabbitmq_3.svg" class="scale-to-fit" src="_images/miros_rabbitmq_3.svg" /></a>
<p>The MirosNets object is the thing that actually builds up the mesh, the snoop_trace and
the snoop_spy networks.  It also provides the means to specify a custom
serializer and de-serializer function.  If custom serialization routines are
not specified it will use pickle version 3.  A MirosNets object can be programmed with
custom callback functions that are triggered when messages are received on any
of the three networks.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It doesn’t take long before UML class diagrams turn into a poem written for the
poet himself, a work that no one else understands or wants to endure.  My
pictures are about to reach this level of conceit; their utility
diminishes with the addition of each detail.  If you’re going to follow this
design I recommend using whatever code navigation tool you have installed.
I’ll colour the parts of the diagram so you know what the docs are referencing
in the picture.</p>
</div>
<a class="reference external image-reference" href="_static/miros_rabbitmq_4.pdf"><img alt="_images/miros_rabbitmq_4.svg" class="scale-to-fit" src="_images/miros_rabbitmq_4.svg" /></a>
<p>The MirosNets class builds up and manages the three RabbitMQ networks which are
accessible from each node in your system.  Before I explain it I would like to
talk more about the networks, and how RabbitMQ structures its network topology.</p>
<p>Let’s first talk about one network, then talk about all of the networks.</p>
<p>Each RabbitMQ node in the network needs one consumer and one or more producers: one producer for
every other node in the network.</p>
<p>Here is a simplified drawing of a single node on a network:</p>
<a class="reference external image-reference" href="_static/network_1.pdf"><img alt="_images/network_1.svg" class="noscale-center" src="_images/network_1.svg" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Normally RabbitMQ drawings contain and exchange and a queue, but we will remove
this information from our drawings to make them easier to understand.</p>
</div>
<p>It is easy to build a consumer using pika with RabbitMQ.  You just need to know
the RabbitMQ credentials for the machine it is running on.</p>
<p>Things are a more complicated when you want to build a producer.  Each producer
needs to know the address and the RabbitMQ credentials for the server running on
the machine it wants to talk to.  Often your program won’t know these details
when it starts.  It will have to search the network to find other machines it
can communicate with.</p>
<p>I’ll try to express this idea with a picture. Consider three nodes in a network:</p>
<a class="reference external image-reference" href="_static/network_3.pdf"><img alt="_images/network_3.svg" class="noscale-center" src="_images/network_3.svg" /></a>
<p>Before a node’s producers can communicate with other nodes, they have to
discover that nodes network address.  Once a producer has this information, it
can establish a connection with that other node’s consumer. (draw an arrow)</p>
<p>Let’s add a bit more detail.  Each network will have a symmetric encryption key
and a serialization/deserialization (pickle) technique.  The consumer on the
local node and all of the producers on all other nodes will have to share these
ways of doing things.</p>
<p>I’ll try to express these ideas with a picture of a network containing two
nodes:</p>
<a class="reference external image-reference" href="_static/network_2_complicated.pdf"><img alt="_images/network_2_complicated.svg" class="scale-to-fit" src="_images/network_2_complicated.svg" /></a>
<p>Any message sent from a program will be serialized and encrypted then dispatched
to each of its producers.  Each producer will send this information out to it’s
consumer.  After a consumer receives a message it will decrypt then deserialize
the message.  The deserilization process will turn the bytestream back into a
Python object.  This Python object will be sent out to the program using the
miros-rabbitmq library.</p>
<p>Now consider the RabbitMQ way of drawing our networks:</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_network_0.pdf"><img alt="_images/miros_rabbitmq_network_0.svg" class="scale-to-fit" src="_images/miros_rabbitmq_network_0.svg" /></a>
<p>We see that the producers communicate their messages to an exchange, which is
actually running on many machines.  The RabbitMQ people merge their exchange
diagrams together in what I think is a kind of short hand.  There is an exchange
on your client, and there is an exchange with the same name on each of the nodes
it is talking to.  They show it as one exchange to simplify their network
drawings.</p>
<p>So, the statechart which wants to transmit and event across it’s network will
use the <code class="docutils literal notranslate"><span class="pre">transmit</span></code> api of the NetworkedFactory or NetworkedActiveObject class.
It will be sent across the network, and end up in the queue of every other
attached active object, as if the event was posted into it’s fifo.  The user
shouldn’t have to worry about how this is done.</p>
<p>Now what happens when a new node is discovered on the network, but your program
has already been started?  No problem, the miros-rabbitmq library will update
all of it’s producers lists in each of its networks so that this node can be
reached.</p>
<p>There is actually a concurrent statechart that manages this part of the library,
it is derived from the
<a class="reference internal" href="#how-it-works2-the-producer-factory-chart"><span class="std std-ref">ProducerFactoryChart</span></a> class.
The ProducerFactoryChart outputs all of it’s newly discovered producers as an
item in a queue.  This item is in the form of a ProducerQueue named tuple.</p>
<a class="reference external image-reference" href="_static/medium_context_producer_factory.pdf"><img alt="_images/medium_context_producer_factory.svg" class="noscale-center" src="_images/medium_context_producer_factory.svg" /></a>
<p>To launch this producer discovery process, the ProducerFactoryChart needs to be
built within the MirosNets class with a queue from which it will pluck any new
producer list:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># top of program</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span> <span class="k">as</span> <span class="n">ThreadQueue</span>
<span class="c1"># .</span>
<span class="c1"># .</span>
<span class="c1"># code in MirosNets __init__ method</span>
<span class="bp">self</span><span class="o">.</span><span class="n">producers_queue</span> <span class="o">=</span> <span class="n">ThreadQueue</span><span class="p">()</span>

<span class="c1"># The producer factory chart will update the producers_queue with new</span>
<span class="c1"># producers as they are found</span>
<span class="bp">self</span><span class="o">.</span><span class="n">producer_factory_chart</span> <span class="o">=</span> <span class="n">ProducerFactoryChart</span><span class="p">(</span>
  <span class="n">producer_queue</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">producers_queue</span><span class="p">,</span>
  <span class="n">mesh_routing_key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">tx_routing_key</span><span class="p">,</span>
  <span class="n">mesh_exchange_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">exchange_name</span><span class="p">,</span>
  <span class="n">mesh_serialization_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">serializer</span><span class="p">,</span>
  <span class="n">snoop_trace_routing_key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snoop</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">routing_key</span><span class="p">,</span>
  <span class="n">snoop_trace_exchange_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snoop</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">exchange_name</span><span class="p">,</span>
  <span class="n">snoop_spy_routing_key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snoop</span><span class="o">.</span><span class="n">spy</span><span class="o">.</span><span class="n">routing_key</span><span class="p">,</span>
  <span class="n">snoop_spy_exchange_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snoop</span><span class="o">.</span><span class="n">spy</span><span class="o">.</span><span class="n">exchange_name</span><span class="p">)</span>

<span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">producers</span> <span class="o">=</span> <span class="p">[]</span>
<span class="bp">self</span><span class="o">.</span><span class="n">snoop</span><span class="o">.</span><span class="n">spy</span><span class="o">.</span><span class="n">producers</span> <span class="o">=</span> <span class="p">[]</span>
<span class="bp">self</span><span class="o">.</span><span class="n">snoop</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">producers</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>The MirosNet object, which starts the ProducerFactoryChart monitors it’s
producer queue at the moment it receives a transmit message:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">transmit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
  <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_producers</span><span class="p">():</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">start_threads</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">producer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">producers</span><span class="p">:</span>
    <span class="n">producer</span><span class="o">.</span><span class="n">post_fifo</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">update_producers</span></code> method looks like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update_producers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="n">discovered</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">producers_queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
    <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">producers_queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="c1"># if we have made producers before stop them now</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">producers</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">stop_threads</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">producers</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">mesh_producers</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">snoop</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">producers</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">snoop_trace_producers</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">snoop</span><span class="o">.</span><span class="n">spy</span><span class="o">.</span><span class="n">producers</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">snoop_spy_producers</span>
    <span class="n">discovered</span> <span class="o">=</span> <span class="bp">True</span>
  <span class="k">return</span> <span class="n">discovered</span>
</pre></div>
</div>
<p>To summarize the producer discovery process: MirosNets constructs a
<a class="reference internal" href="#how-it-works2-the-producer-factory-chart"><span class="std std-ref">ProducerFactoryChart</span></a> with a
queue.  The <code class="docutils literal notranslate"><span class="pre">transmit</span></code> method, will see if new producers have been put in this
queue.  If new producers were discovered, the old producers will have their threads turned
off, and the new producers will have their threads started and the item that is being
transmitted out to the network will be posted into the object that is running
each producer.</p>
<p>A producer is actually built using a PikaTopicPublisher object which wraps the
SimplePikaTopicPublisher with encryption and serialization methods.</p>
<p>The SimplePikaTopicPublisher is the thing that actually performs the network
publishing function of this library.  It is heavily based upon the <a class="reference external" href="http://pika.readthedocs.io/en/0.11.2/examples/asynchronous_publisher_example.html">asynchronous
pika publisher example</a>
provided in the pika library documentation.</p>
<p>Before using this example as a base for the publishing feature I used the
example provided on the RabbitMQ page.  The code based on these examples would
run for about 15 minutes prior to failing.  I gave up trying to troubleshoot the
issue because of the slow feedback time between failures.  Since re-writing
everything based on the much more complicated <a class="reference external" href="http://pika.readthedocs.io/en/0.11.2/examples/asynchronous_publisher_example.html">asynchronous pika publisher
example</a>
the connections have been stable.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The pika example was very mysterious about how it was actually
suppose to be used.  There are a lot of questions about it on stackover flow;
more open secrets abound in this community.</p>
</div>
<p>The SimplePikaTopicPublisher class is different than the pika asynchronous
publisher example provided in their documentation, in that it has a thread who’s
sole purpose is to wrap the <code class="docutils literal notranslate"><span class="pre">run</span></code> method provided by their example.  The <code class="docutils literal notranslate"><span class="pre">run</span></code>
method runs forever, and no code below it in the file will ever have access to
the CPU.  So, by wrapping the <code class="docutils literal notranslate"><span class="pre">run</span></code> method in a thread, it can do its thing
without destroying the program flow.  This <code class="docutils literal notranslate"><span class="pre">run</span></code> method provides an event loop
in which pika can send out messages to the network using callbacks, the most
important of which is the <code class="docutils literal notranslate"><span class="pre">producer_heart_beat</span></code>.  When this <code class="docutils literal notranslate"><span class="pre">producer_heart_beat</span></code>
callback is called, it checks a queue to see if anyone in another thread wants to
send something.  If so, it creates a partial function from the
<code class="docutils literal notranslate"><span class="pre">publish_message</span></code> callback using the message provided by the queue.  It then
schedules the new wrapped <code class="docutils literal notranslate"><span class="pre">publish_message</span></code> to be called immediately by the
pika event loop.  After clearing the queue in this way, it schedules itself with
the pika event loop so that it will be rerun sometime in the future.  I added
some code to control this time-out duration.  If there are a lot of messages in
the queue, the <code class="docutils literal notranslate"><span class="pre">producer_heart_beat</span></code> will occur quicker than it did before, if
there are no items in the queue it will relax its time-out duration to it’s
slowest default tempo.  This tempo-time-control feature was made using a
PID controller.</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_network_0.pdf"><img alt="_images/miros_rabbitmq_network_0.svg" class="scale-to-fit" src="_images/miros_rabbitmq_network_0.svg" /></a>
<p>The MirosNets only has one consumer per network.  The consumer’s responsiblity is
to respond to messages coming from the RabbitMQ service, to decrypt,
de-serialize them then to dispatch them out to whatever needs to know about this
information.  In the case of the Mesh network, a message is dispatched into the
statechart’s FIFO.  In the case of the snoop trace and snoop spy networks, the
messages are formatted with colour and output to the terminal.</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_6.pdf"><img alt="_images/miros_rabbitmq_6.svg" class="noscale-center" src="_images/miros_rabbitmq_6.svg" /></a>
<p>The PikaTopicConsumer provides the decryption and deserialization for each
network consumer.</p>
<p>PikaTopicConsumer is a subclass of SimplePikaTopicConsumer, which is heavily
based upon the <a class="reference external" href="http://pika.readthedocs.io/en/0.11.2/examples/asynchronous_consumer_example.html">asynchronous pika consumer example.</a></p>
<p>The PikaTopicConsumer class is different from the <a class="reference external" href="http://pika.readthedocs.io/en/0.11.2/examples/asynchronous_consumer_example.html">asynchronous pika consumer
example.</a>
in that it wraps the <code class="docutils literal notranslate"><span class="pre">run</span></code> method in a thread (as in the producer). The
<code class="docutils literal notranslate"><span class="pre">run</span></code> method starts a pika event loop.  A
<code class="docutils literal notranslate"><span class="pre">timeout_callback_method</span></code> runs within pika producer’s event loop.  It checks to see if
another thread wants to stop the consumer, if so, it kills the pika event loop,
if not, it registers itself as a callback sometime in the future.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">on_message</span></code> of PikaTopicConsumer class is never called because it is
overloaded by the PikaTopicConsumer.  The <code class="docutils literal notranslate"><span class="pre">on_message</span></code> method of the
PikaTopicConsumer decrypts and deserializes any message received by RabbitMq.
It takes the result and passes it onto the
<code class="docutils literal notranslate"><span class="pre">message_callback</span></code> that was registerd with the class.  This
<code class="docutils literal notranslate"><span class="pre">message_callback</span></code> is provided in it’s constructor.  It is the MirosNets class
which constructs 3 (one per network) of these objects and its <code class="docutils literal notranslate"><span class="pre">on_message</span></code>
callback functions are provided by the NetworkedActiveObject and
NetworkedFactory.  The common <code class="docutils literal notranslate"><span class="pre">on_message</span></code> behavior of the
NetworkedActiveObject and NetworkedFactory are provided by the
MirosNetsInterface.</p>
<div class="section" id="slight-extension-to-the-diagramming-rules">
<h2>Slight Extension to the Diagramming Rules<a class="headerlink" href="#slight-extension-to-the-diagramming-rules" title="Permalink to this headline">#</a></h2>
<p>When building a statechart which publishes events and subscribes to events it is
important to see these locations on your map.  They are the inputs and outputs
of your statechart.  These pub/sub events are decoupled calls to software that
doesn’t exist on the page, so I have added two little coloured dots on my
diagrams to make things easier to see.</p>
<ul class="simple">
<li><p>A red dot is placed near an event that is publishing a signal.  A publishing
event puts something into a queue which is waiting for attention.  So, it is
stopped, like being at a red light.</p></li>
<li><p>A green dot is placed near an event that has been subscribed to and has been
published somewhere else in the software system.  It is green, like a green
light; it is time to go.</p></li>
</ul>
<p>The payloads of the published and subscribed events act as an interface for this
asynchronous API.  To keep things clean, all payloads will exist as named
tuples.  These tuples will be put into ‘note’ icons near the place that they are
made (published) or consumed.</p>
</div>
<div class="section" id="the-producer-factory-chart">
<span id="how-it-works2-the-producer-factory-chart"></span><h2>The Producer Factory Chart<a class="headerlink" href="#the-producer-factory-chart" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code> is used to build RabbitMQ producers as they are
discovered by the miros-rabbitmq library.</p>
<p>Before you can build a producer, you need to know what other RabbitMQ server it
is aimed at on the network.  Then you have to provide its constructor with all
of the RabbitMQ credentials, encryption keys and other parameters so that it is
build up properly.  Furthermore, the miros-rabbitmq library needs three
producers per target in the network, one for the mesh network and two for the
different instrumentation channels.  The <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code> tries to hide
all of this complexity from the user.  It was designed to:</p>
<ul class="simple">
<li><p>Initiate a search for other RabbitMQ servers on the LAN, using the <a class="reference internal" href="#how-it-works2-the-lanreccechart"><span class="std std-ref">LanChart</span></a></p></li>
<li><p>Initiate a search based on the user’s manual network settings, using the <a class="reference internal" href="#how-it-works2-manual-netword-chart"><span class="std std-ref">ManNetChart</span></a></p></li>
<li><p>Respond to messages from unknown hosts with the correct encryption credentials
(Aliens).</p></li>
<li><p>React to the discovery of servers running RabbitMQ instances with the correct
encryption and RabbitMQ credentials by building up instances of three
different producers per discovery: a mesh producer and a snoop trace and snoop
spy producer.</p></li>
<li><p>Serve up it’s constructed list of producers to another thread, using a queue.</p></li>
</ul>
<p>To understand the point of the <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code> we need to look at the
RabbitMQ architectural diagram used by the miros-rabbitmq plugin:</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_network_0.pdf"><img alt="_images/miros_rabbitmq_network_0.svg" class="scale-to-fit" src="_images/miros_rabbitmq_network_0.svg" /></a>
<p>The hard part about setting up the above diagram is building the producer
collections.</p>
<p>The three different networks each have their own producer objects which are
pre-loaded with the destination information of the servers that they want to
communicate with.  The members of the producer collection can change as new
servers are discovered, or removed from the network.  It is the job of the
<code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code> to keep these lists up to date for the other parts of
the program that need them.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code> actually works by orchestrating a number of
different state charts.  It builds the
<a class="reference internal" href="#how-it-works2-manual-netword-chart"><span class="std std-ref">ManNetChart</span></a> and the <a class="reference internal" href="#how-it-works2-the-lanreccechart"><span class="std std-ref">LanChart</span></a>, which in turn build the statecharts that
they need.</p>
<a class="reference external image-reference" href="_static/small_context_producer_factory.pdf"><img alt="_images/small_context_producer_factory.svg" class="noscale-center" src="_images/small_context_producer_factory.svg" /></a>
<p>From a very high level the <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code>, consumes
<code class="docutils literal notranslate"><span class="pre">CONNECTION_DISCOVERY</span></code> events and puts its newly constructed producers into a
queue using the <code class="docutils literal notranslate"><span class="pre">ProducerQueue</span></code> namedtuple:</p>
<a class="reference external image-reference" href="_static/medium_context_producer_factory.pdf"><img alt="_images/medium_context_producer_factory.svg" class="scale-to-fit" src="_images/medium_context_producer_factory.svg" /></a>
<p>The thread which consumes this queue doesn’t have to deal with any of the
producer construction complexity.  It will just check to see if a new item was
added to the queue, if so, it will update it’s producers with the information in
this new item.</p>
<p>The actual architectural diagram of the <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code> can be seen
here:</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_producer_discovery.pdf"><img alt="_images/miros_rabbitmq_producer_discovery.svg" class="noscale-center" src="_images/miros_rabbitmq_producer_discovery.svg" /></a>
<p>The class which makes a RabbitMQ producer is called the <code class="docutils literal notranslate"><span class="pre">ProducerFactory</span></code>, it is
subclassed as the <code class="docutils literal notranslate"><span class="pre">MeshProducerFactory</span></code>, <code class="docutils literal notranslate"><span class="pre">SnoopTraceProducerFactory</span></code> and
<code class="docutils literal notranslate"><span class="pre">SnoopSpyProducerFactory</span></code>.  The <code class="docutils literal notranslate"><span class="pre">ProducerFactoryAggregator</span></code> class is a
subclass of the miros <code class="docutils literal notranslate"><span class="pre">Factory</span></code>, its purpose is to contain all of the worker
methods that are custom to the <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code> inherits from the <code class="docutils literal notranslate"><span class="pre">ProducerFactoryAggregator</span></code>, so
that it has access to all of its needed worker methods and the event processor
from the <code class="docutils literal notranslate"><span class="pre">miros</span></code> <code class="docutils literal notranslate"><span class="pre">Factory</span></code> class.</p>
<p>To build a <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code>, you will first need to provide a custom
serializer function for dealing with miros Event objects and you will need a
queue where it will place it’s results, then you provide the routing_key and
exchange information:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">queue</span>
<span class="k">def</span> <span class="nf">custom_serializer</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Event</span><span class="p">):</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Event</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
  <span class="n">pobj</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">pobj</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>

<span class="n">producer_refactory</span> <span class="o">=</span> <span class="n">ProducerFactoryChart</span><span class="p">(</span>
   <span class="n">producer_queue</span><span class="o">=</span><span class="n">q</span><span class="p">,</span>
   <span class="n">mesh_routing_key</span> <span class="o">=</span> <span class="s1">&#39;heya_man&#39;</span><span class="p">,</span>
   <span class="n">mesh_exchange_name</span> <span class="o">=</span> <span class="s1">&#39;miros.mesh.exchange&#39;</span><span class="p">,</span>
   <span class="n">mesh_serialization_function</span><span class="o">=</span><span class="n">custom_serializer</span><span class="p">,</span>
   <span class="n">snoop_trace_routing_key</span> <span class="o">=</span> <span class="s1">&#39;snoop.trace&#39;</span><span class="p">,</span>
   <span class="n">snoop_trace_exchange_name</span> <span class="o">=</span> <span class="s1">&#39;miros.snoop.trace&#39;</span><span class="p">,</span>
   <span class="n">snoop_spy_routing_key</span> <span class="o">=</span> <span class="s1">&#39;snoop.spy&#39;</span><span class="p">,</span>
   <span class="n">snoop_spy_exchange_name</span> <span class="o">=</span> <span class="s1">&#39;miros.snoop.spy&#39;</span><span class="p">,</span>
   <span class="n">live_trace</span><span class="o">=</span><span class="bp">True</span>
<span class="p">)</span>
</pre></div>
</div>
<p>In the above listing I also enabled the trace.  This is useful for debugging and
documenting how the <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code> state machine works.</p>
<p>Look at the state machine part of this diagram:</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_producer_discovery.pdf"><img alt="_images/miros_rabbitmq_producer_discovery.svg" class="noscale-center" src="_images/miros_rabbitmq_producer_discovery.svg" /></a>
<p>We see that in the <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code> that there are three states, the
<code class="docutils literal notranslate"><span class="pre">producer_discovery</span></code>, the <code class="docutils literal notranslate"><span class="pre">post_to_queue</span></code> and the <code class="docutils literal notranslate"><span class="pre">refactor_producers</span></code>
states.  When the <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code> is constructed, it immediately
transitions into the <code class="docutils literal notranslate"><span class="pre">producer_discovery</span></code> state.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">producer_discovery</span></code> creates the
<a class="reference internal" href="#how-it-works2-manual-netword-chart"><span class="std std-ref">ManNetChart</span></a> and the
<a class="reference internal" href="#how-it-works2-mirosrabbitlanchart"><span class="std std-ref">LanChart</span></a> upon entry.  It subscribes to
the <code class="docutils literal notranslate"><span class="pre">CONNECTION_DISCOVERY</span></code> event and stops.  The <code class="docutils literal notranslate"><span class="pre">ProducerFactoryChart</span></code>
doesn’t know or care how connections are discovered, it is up to the other
charts to do this work.  All it does is convert new IP information into working
producers which can be used by the thread pending on it’s output queue.  This
new IP information is delivered to it in <code class="docutils literal notranslate"><span class="pre">CONNECTION_DISCOVERY</span></code> events.</p>
<p>Upon receiving a <code class="docutils literal notranslate"><span class="pre">CONNECTION_DISCOVERY</span></code> event from either the
<a class="reference internal" href="#how-it-works2-manual-netword-chart"><span class="std std-ref">ManNetChart</span></a> object or the
<a class="reference internal" href="#how-it-works2-mirosrabbitlanchart"><span class="std std-ref">LanChart</span></a> object, it determines if any
new IP addresses were discovered.</p>
<p>The first time a <code class="docutils literal notranslate"><span class="pre">CONNECTION_DISCOVERY</span></code> event is received this will
undoubtedly be true.  It determines what the new IP addresses are and what all
of the IP addresses are.  If there is new information it will post a
<code class="docutils literal notranslate"><span class="pre">ips_discovered</span></code> event to itself.  Then it tries to destroy which ever chart
delivered the message.  The actual destruction of the object will be done by the
Python garbage collector, the <code class="docutils literal notranslate"><span class="pre">producer_discovery</span></code> state just stops
referencing the object so that the garbage collector will see that it is no
longer being used.</p>
<p>The purpose of the <code class="docutils literal notranslate"><span class="pre">post_to_queue</span></code> state is to defer any
<code class="docutils literal notranslate"><span class="pre">CONNECTION_DISCOVERY</span></code> events from occurring while the state chart is dealing
with an exception from posting to the <code class="docutils literal notranslate"><span class="pre">producer_queue</span></code>.  This is an example of
the <a class="reference external" href="https://aleph2c.github.io/miros/patterns.html#patterns-deferred-event">deferred event</a>
statechart pattern.  By using this pattern, we are modifying the sequence of
events.  To make sense of this, place your eyes on the
<code class="docutils literal notranslate"><span class="pre">chart.producer_queue.put</span></code> syntax in the <code class="docutils literal notranslate"><span class="pre">refactor_producers</span></code> part of the
statechart.  If there is an exception here, like if the queue is full because
the other part of the program hasn’t cleared it yet, we need to try posting to
the queue again in the future.  So, we start a one_shot timer with a time
between 0.1 and 1 second.  We pick a random time so as to avoid any issues with
other parts of the program trying to do the same thing.  Now suppose we are
waiting to try posting to our queue again and another <code class="docutils literal notranslate"><span class="pre">CONNECTION_DISCOVERY</span></code>
event comes in?  What do we do?  Well, we deferred the event into the deferred
event queue, only releasing it back to the statechart upon exiting the
<code class="docutils literal notranslate"><span class="pre">post_to_queue</span></code> state.  Sometime in the future
the <code class="docutils literal notranslate"><span class="pre">ips_discovered</span></code> event is fired and captured by the <code class="docutils literal notranslate"><span class="pre">post_to_queue</span></code>
state so that it can try to post the queue again.  If it succeeds, a <code class="docutils literal notranslate"><span class="pre">ready</span></code>
event will fire, which will cause the <code class="docutils literal notranslate"><span class="pre">exit</span></code> event of the <code class="docutils literal notranslate"><span class="pre">post_to_queue</span></code>
state to fire.  This will recall the <code class="docutils literal notranslate"><span class="pre">CONNECTION_DISCOVERY</span></code> event that was
salted away and the whole discovery process can be started again.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">refactor_producers</span></code> state entry condition creates a set of new producers
using the <code class="docutils literal notranslate"><span class="pre">make_mesh_producers</span></code>, <code class="docutils literal notranslate"><span class="pre">make_snoop_trace_producers</span></code> and the
<code class="docutils literal notranslate"><span class="pre">make_snoop_spy_producers</span></code> worker functions defined within the
<code class="docutils literal notranslate"><span class="pre">ProducerFactoryAggregator</span></code> class.  The new producers are appended into their
appropriate collections, then these collections are organized into the
<code class="docutils literal notranslate"><span class="pre">ProducerQueue</span></code> namedtuple.  This namedtuple object is place into the queue.
If there is a problem with this process, the activity described in the previous
paragraph is followed.  If there are no problems, the thread pending on this
queue can extract the new producer information as it sees fit.</p>
<p>After successfully putting the new producer information into the queue, the
statechart posts a <code class="docutils literal notranslate"><span class="pre">ready</span></code> signal to itself.  This will allow it to process
any pending <code class="docutils literal notranslate"><span class="pre">CONNECTION_DISCOVERY</span></code> events.</p>
<p id="how-it-works2-aliens">The ProducerFactoryChart also has a way of reacting to a previously unknown
machine sending messages with the correct mesh encryption key, and using the
correct RabbitMQ credentials.  For lack of a better word, let’s call these nodes
Aliens.  A machine that will not respond to a ping on the LAN and who’s address
we forgot to add to our <code class="docutils literal notranslate"><span class="pre">.miros_rabbitmq_hosts</span></code> file, but who still knows
about us, is an example of an Alien.</p>
<a class="reference external image-reference" href="_static/medium_context_miros_nets.pdf"><img alt="_images/medium_context_miros_nets.svg" class="noscale-center" src="_images/medium_context_miros_nets.svg" /></a>
<p>It is the MirosNets class that can discover Aliens.  It has a list of
<code class="docutils literal notranslate"><span class="pre">ip_addresses</span></code> that it updates when it receives items in it’s
<code class="docutils literal notranslate"><span class="pre">producers_queue</span></code>.</p>
<p>It also receives messages from other nodes, and after it has decrypted the
message, it can look to see who sent the message during it’s deserialization
step.</p>
<p>If it hasn’t seen this address before, it constructs a
ConnectionDiscoveryPayload, adds it to a <code class="docutils literal notranslate"><span class="pre">CONNECTION_DISCOVERY</span></code> event and
feeds this to the ProducerFactoryChart.</p>
<p>The ProducerFactoryChart uses this information to create the three different
producers, and then feeds this information back to the MirosNets object using
the producers_queue.  The MirosNet’s updates its list of known <code class="docutils literal notranslate"><span class="pre">ip_addresses</span></code>
and starts communicating to the Alien using the producers provided to it by the
ProducerFactoryChart.  At this point, the Alien node is no longer really an
Alien anymore, because the node is known and it is being spoken too.</p>
</div>
<div class="section" id="lanchart">
<span id="how-it-works2-mirosrabbitlanchart"></span><h2>LanChart<a class="headerlink" href="#lanchart" title="Permalink to this headline">#</a></h2>
<p>The LanChart is responsible for finding other RabbitMQ servers on your Local
Area Network.  It publishes its results into a CONNECTION_DISCOVERY event.  It was
designed to:</p>
<ul class="simple">
<li><p>be created/started/destroyed within another statechart</p></li>
<li><p>use cached information if it hasn’t expired (to save time)</p></li>
<li><p>perform a LAN discovery process if the cache is expired, then cache this
result for the next run of the program</p></li>
<li><p>output a set of working AMQP urls as the payload of the CONNECTION_DISCOVERY
event.</p></li>
</ul>
<p>The LanChart is built by the <a class="reference internal" href="#how-it-works2-the-producer-factory-chart"><span class="std std-ref">ProducerFactoryChart</span></a>.  The LanChart doesn’t search the LAN or reference the cache directly, it gets this information from a <a class="reference internal" href="#how-it-works2-the-lanreccechart"><span class="std std-ref">LanRecceChart</span></a> and a <a class="reference internal" href="#cfc"><span class="std std-ref">CacheFileChart</span></a> object:</p>
<a class="reference external image-reference" href="_static/small_context_lan_chart.pdf"><img alt="_images/small_context_lan_chart.svg" class="noscale-center" src="_images/small_context_lan_chart.svg" /></a>
<p>From a high level, the LanChart subscribes to 2 events and publishes 4 events:</p>
<a class="reference external image-reference" href="_static/medium_context_lan_chart.pdf"><img alt="_images/medium_context_lan_chart.svg" class="scale-to-fit" src="_images/medium_context_lan_chart.svg" /></a>
<p>Here is the architectural diagram for this statechart:</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_lan_discovery.pdf"><img alt="_images/miros_rabbitmq_lan_discovery.svg" class="scale-to-fit" src="_images/miros_rabbitmq_lan_discovery.svg" /></a>
<p>To construct a LanChart use the <code class="docutils literal notranslate"><span class="pre">routing_key</span></code> and the
<code class="docutils literal notranslate"><span class="pre">exchange_name</span></code> of the RabbitMQ servers you are trying to connect to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">LanChart</span><span class="p">(</span>
  <span class="n">routing_key</span><span class="o">=</span><span class="s1">&#39;heya.man&#39;</span><span class="p">,</span>
  <span class="n">exchange_name</span><span class="o">=</span><span class="s1">&#39;miros.mesh.exchange&#39;</span><span class="p">,</span>
  <span class="n">live_trace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># to debug or document</span>
</pre></div>
</div>
<p>By default it will look for a file called <code class="docutils literal notranslate"><span class="pre">.miros_rabbitmq_lan_cache.json</span></code> which
will look something like this:</p>
<div class="highlight-JSON notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;addresses&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="s2">&quot;192.168.1.75&quot;</span>
  <span class="p">],</span>
  <span class="nt">&quot;amqp_urls&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="s2">&quot;amqp://bob:dobbs@192.168.1.75:5672/%2F?connection_attempts=3&amp;heartbeat_interval=3600&quot;</span>
  <span class="p">],</span>
  <span class="nt">&quot;time_out_in_minutes&quot;</span><span class="p">:</span> <span class="mi">30</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the cached file is older than the <code class="docutils literal notranslate"><span class="pre">time_out_in_minutes</span></code>,
LanChart will transition into it’s <code class="docutils literal notranslate"><span class="pre">discover_network</span></code> state,
discover the network then write the <code class="docutils literal notranslate"><span class="pre">.miros_rabbitmq_lan_cache.json</span></code> file with
the results.</p>
<p>To change the cache file’s time out, add <code class="docutils literal notranslate"><span class="pre">time_out_in_minutes</span></code> as a named
parameter when you are constructing your <code class="docutils literal notranslate"><span class="pre">LanChart</span></code> object.  Here
is an example of changing the timeout to 60 minutes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">LanChart</span><span class="p">(</span>
  <span class="n">routing_key</span><span class="o">=</span><span class="s1">&#39;heya.man&#39;</span><span class="p">,</span>
  <span class="n">exchange_name</span><span class="o">=</span><span class="s1">&#39;miros.mesh.exchange&#39;</span><span class="p">,</span>
  <span class="n">time_out_in_minutes</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-lanreccechart">
<span id="how-it-works2-the-lanreccechart"></span><h2>The LanRecceChart<a class="headerlink" href="#the-lanreccechart" title="Permalink to this headline">#</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The word Recce is the Canadian/British way of saying recon.  Recon, is the
short form of the word reconnaissance.  I didn’t know this before I googled
recon, but being a good Canadian I decided to use <code class="docutils literal notranslate"><span class="pre">recce</span></code> to name the
objects and classes in the part of the design, instead of the word recon (we
all have to do our parts to resist American cultural hegemony).</p>
<p>Being new to the word I had to figure out how to say it, recce is pronounced
like ‘wreck-ee’. (I learned this from an American)</p>
</div>
<p>The LanRecceChart performs multiple scouting missions of your local area network
for compatible RabbitMQ consumers.  The LanRecceChart was designed to:</p>
<ul class="simple">
<li><p>be created/started/destroyed within another statechart</p></li>
<li><p>hide the complexity of the local area networking search details</p></li>
<li><p>build a set of search criterion based on it’s LAN discovery process</p></li>
<li><p>rely on the RabbitConsumerScoutChart specialists to perform the individual
scouting missions for compatible RabbitMQ consumers.</p></li>
<li><p>perform all of it’s scouting missions in parallel</p></li>
<li><p>work in Linux and on the Windows Linux Subsystem</p></li>
<li><p>provide it’s result in the form of asynchronous events to which other
statecharts can subscribe.</p></li>
<li><p>be easy to debug/document</p></li>
</ul>
<p>The LanRecceChart is build by the
<a class="reference internal" href="#how-it-works2-mirosrabbitlanchart"><span class="std std-ref">LanChart</span></a> object and it builds many
different <a class="reference internal" href="#how-it-works2-producescoutchart"><span class="std std-ref">RabbitConsumerScoutChart</span></a>
objects:</p>
<a class="reference external image-reference" href="_static/small_context_lan_recce_chart.pdf"><img alt="_images/small_context_lan_recce_chart.svg" class="noscale-center" src="_images/small_context_lan_recce_chart.svg" /></a>
<p>From a high level, the LanRecceChart subscribes the <code class="docutils literal notranslate"><span class="pre">RECCEN_LAN</span></code> event and
publishes the <code class="docutils literal notranslate"><span class="pre">LAN_RECCE_COMPLETE</span></code> event.</p>
<a class="reference external image-reference" href="_static/medium_context_lan_recce_chart.pdf"><img alt="_images/medium_context_lan_recce_chart.svg" class="scale-to-fit" src="_images/medium_context_lan_recce_chart.svg" /></a>
<p>Here is the design diagram for the LanRecceChart, if it is too small, click on
the picture to download a pdf of the diagram:</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_recce_chart.pdf"><img alt="_images/miros_rabbitmq_recce_chart.svg" class="scale-to-fit" src="_images/miros_rabbitmq_recce_chart.svg" /></a>
<p>The LanRecce class, inherited by the LanRecceChart contains all of the methods
required to search your local area network and your local machine for the IP
addresses needed to begin a search for compatible RabbitMQ consumers.  The three
main methods used by the LanRecceChart during the dynamic portion of it’s life
are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LanRecce.get_working_ip_address</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ping_to_fill_arp_table</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">candidiate_ip_addresses</span></code></p></li>
</ul>
</div></blockquote>
<p>The rest of the methods help these main methods perform their required tasks.</p>
<p>To build a CacheFileChart with a live_trace:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lan_recce</span> <span class="o">=</span> <span class="n">LanRecceChart</span><span class="p">(</span>
    <span class="n">routing_key</span><span class="o">=</span><span class="s1">&#39;heya.man&#39;</span><span class="p">,</span>
    <span class="n">exchange_name</span><span class="o">=</span><span class="s1">&#39;miros.mesh.exchange&#39;</span><span class="p">,</span>
    <span class="n">live_trace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The LanRecceChart does not start itself.  The statechart that wants to start the
network reconnaissance will have to publish a <code class="docutils literal notranslate"><span class="pre">RECCE_LAN</span></code> event or use the
<code class="docutils literal notranslate"><span class="pre">post_fifo</span></code> method on the <code class="docutils literal notranslate"><span class="pre">LanRecceChart</span></code> object with the <code class="docutils literal notranslate"><span class="pre">RECCE_LAN</span></code>
event.  Let’s just post to it directly using the <code class="docutils literal notranslate"><span class="pre">post_fifo</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lan_recce</span><span class="o">.</span><span class="n">post_fifo</span><span class="p">(</span><span class="n">Event</span><span class="p">(</span><span class="n">signals</span><span class="o">.</span><span class="n">RECCE_LAN</span><span class="p">))</span>
</pre></div>
</div>
<p>Now let’s look at the trace:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">2018</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mi">56</span><span class="p">:</span><span class="mf">54.372046</span><span class="p">]</span> <span class="p">[</span><span class="n">lan_recce_chart</span><span class="p">]</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">start_at</span><span class="p">()</span> <span class="n">top</span><span class="o">-&gt;</span><span class="n">private_search</span>
<span class="p">[</span><span class="mi">2018</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mi">56</span><span class="p">:</span><span class="mf">54.372522</span><span class="p">]</span> <span class="p">[</span><span class="n">lan_recce_chart</span><span class="p">]</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">recce_lan</span><span class="p">()</span> <span class="n">private_search</span><span class="o">-&gt;</span><span class="n">fill_arp_table</span>
<span class="p">[</span><span class="mi">2018</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mi">56</span><span class="p">:</span><span class="mf">58.386858</span><span class="p">]</span> <span class="p">[</span><span class="n">lan_recce_chart</span><span class="p">]</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">arp_time_out</span><span class="p">()</span> <span class="n">fill_arp_table</span><span class="o">-&gt;</span><span class="n">identify_all_ip_addresses</span>
<span class="p">[</span><span class="mi">2018</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mi">56</span><span class="p">:</span><span class="mf">58.454212</span><span class="p">]</span> <span class="p">[</span><span class="n">lan_recce_chart</span><span class="p">]</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ip_addresses_found</span><span class="p">()</span> <span class="n">identify_all_ip_addresses</span><span class="o">-&gt;</span><span class="n">recce_rabbit_consumers</span>
<span class="p">[</span><span class="mi">2018</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mi">57</span><span class="p">:</span><span class="mf">00.048376</span><span class="p">]</span> <span class="p">[</span><span class="n">lan_recce_chart</span><span class="p">]</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">lan_recce_complete</span><span class="p">()</span> <span class="n">recce_rabbit_consumers</span><span class="o">-&gt;</span><span class="n">private_search</span>
</pre></div>
</div>
<p>Compare this trace with it’s statechart:</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_recce_chart.pdf"><img alt="_images/miros_rabbitmq_recce_chart.svg" class="scale-to-fit" src="_images/miros_rabbitmq_recce_chart.svg" /></a>
<p>Compare the statechart within the <code class="docutils literal notranslate"><span class="pre">LanRecceChart</span></code> class to the sequence diagram with a description:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Statechart</span><span class="p">:</span> <span class="n">lan_recce_chart</span><span class="p">]</span>
           <span class="n">top</span>     <span class="n">private_search</span>  <span class="n">fill_arp_table</span>  <span class="n">identify_all_ip_addresses</span>  <span class="n">recce_rabbit_consumers</span>
            <span class="o">+-</span><span class="n">start_at</span><span class="p">()</span><span class="o">-&gt;|</span>              <span class="o">|</span>                      <span class="o">|</span>                        <span class="o">|</span>
            <span class="o">|</span>    <span class="p">(</span><span class="mi">1</span><span class="p">)</span>      <span class="o">|</span>              <span class="o">|</span>                      <span class="o">|</span>                        <span class="o">|</span>
            <span class="o">|</span>             <span class="o">+-</span><span class="n">recce_lan</span><span class="p">()</span><span class="o">-&gt;|</span>                      <span class="o">|</span>                        <span class="o">|</span>
            <span class="o">|</span>             <span class="o">|</span>    <span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="o">|</span>                      <span class="o">|</span>                        <span class="o">|</span>
            <span class="o">|</span>             <span class="o">|</span>              <span class="o">+----</span><span class="n">arp_time_out</span><span class="p">()</span><span class="o">---&gt;|</span>                        <span class="o">|</span>
            <span class="o">|</span>             <span class="o">|</span>              <span class="o">|</span>         <span class="p">(</span><span class="mi">3</span><span class="p">)</span>          <span class="o">|</span>                        <span class="o">|</span>
            <span class="o">|</span>             <span class="o">|</span>              <span class="o">|</span>                      <span class="o">+--</span><span class="n">ip_addresses_found</span><span class="p">()</span><span class="o">-&gt;|</span>
            <span class="o">|</span>             <span class="o">|</span>              <span class="o">|</span>                      <span class="o">|</span>          <span class="p">(</span><span class="mi">4</span><span class="p">)</span>           <span class="o">|</span>
            <span class="o">|</span>             <span class="o">+&lt;-------------+----------------------+--</span><span class="n">lan_recce_complete</span><span class="p">()</span><span class="o">--|</span>
            <span class="o">|</span>             <span class="o">|</span>              <span class="o">|</span>                      <span class="o">|</span>          <span class="p">(</span><span class="mi">5</span><span class="p">)</span>           <span class="o">|</span>
</pre></div>
</div>
<ol class="arabic">
<li><p>The <code class="docutils literal notranslate"><span class="pre">LanRecceChart</span></code> starts itself in the <code class="docutils literal notranslate"><span class="pre">private_search</span></code> state.
Immediately upon entering the <code class="docutils literal notranslate"><span class="pre">private_search</span></code> state the state machine
subscribes to the <code class="docutils literal notranslate"><span class="pre">RECCE_LAN</span></code> and <code class="docutils literal notranslate"><span class="pre">AMQP_CONSUMER_CHECK</span></code> events.  The
<code class="docutils literal notranslate"><span class="pre">RECCE_LAN</span></code> event will be used by some outside statechart to begin a search
of the local network and the <code class="docutils literal notranslate"><span class="pre">AMQP_CONSUMER_CHECK</span></code> events will be initiated
within the <code class="docutils literal notranslate"><span class="pre">recce_rabbit_consumers</span></code> state, talked about in step 4.</p>
<p>After subscribing to the public events it uses the <code class="docutils literal notranslate"><span class="pre">get_working_ip_address</span></code>
static to get it’s working IP address.</p>
</li>
<li><p>In response to our posted <code class="docutils literal notranslate"><span class="pre">RECCE_LAN</span></code> event the chart posts a private
<code class="docutils literal notranslate"><span class="pre">recce_lan</span></code> event and begins a search of the local area network.  Notice
that while the state machine is within the <code class="docutils literal notranslate"><span class="pre">lan_recce</span></code> state, all
additional <code class="docutils literal notranslate"><span class="pre">RECCE_LAN</span></code> events will be deferred until the state is exited.
This is an example of the <a class="reference external" href="https://aleph2c.github.io/miros/patterns.html#patterns-deferred-event">deferred event pattern</a>.</p>
<p>After the event processor enters the <code class="docutils literal notranslate"><span class="pre">lan_recce</span></code> state, it’s initialization
signal causes a transition into the <code class="docutils literal notranslate"><span class="pre">fill_arp_table</span></code>.  Upon entering the
<code class="docutils literal notranslate"><span class="pre">file_arp_table</span></code> the state machine pings the broadcast address of the local
network to fill the arp table and triggers a one shot event called
<code class="docutils literal notranslate"><span class="pre">ARP_FILL_TIME_OUT</span></code> to fire in <code class="docutils literal notranslate"><span class="pre">lan.arp_time_sec</span></code>.  This value can be
passed into the LanRecceChart as an optional parameter, by default it is set
to 2 seconds.</p>
</li>
<li><p>2 seconds after step 2, the <code class="docutils literal notranslate"><span class="pre">ARP_FILL_TIME_OUT</span></code> one shot is fired, causing
a transition into the <code class="docutils literal notranslate"><span class="pre">identify_all_ip_addresses</span></code> state.  Upon entering
this state the state machine determines what the network addresses are by
reading the arp table within a call to the <code class="docutils literal notranslate"><span class="pre">candidiate_ip_addresses</span></code>
method.  It then posts the <code class="docutils literal notranslate"><span class="pre">ip_address_found</span></code> event to itself.</p></li>
<li><p>At this stage, each of the discovered IP addresses is used to begin a
scouting mission.  The missions run in parallel using their own
<code class="docutils literal notranslate"><span class="pre">RabbitConsumerScoutChart</span></code> instance.  When a mission is completed, the
result is published by the <code class="docutils literal notranslate"><span class="pre">RabbitConsumerScoutChart</span></code> within the payload of
the <code class="docutils literal notranslate"><span class="pre">AMQP_CONSUMER_CHECK</span></code> event and caught and handled within the
<code class="docutils literal notranslate"><span class="pre">recce_rabbit_consumers</span></code> state.</p>
<p>When all of the searches have returned their respect <code class="docutils literal notranslate"><span class="pre">AMQP_CONSUMER_CHECK</span></code>
the IP addresses that have been confirmed to have a RabbitMQ consumer are put
into the payload of a <code class="docutils literal notranslate"><span class="pre">LAN_RECCE_COMPLETE</span></code> event and published to the task
fabric so that any statechart subscribing to this event will receive the
results of the reconnaissance of the local network.</p>
</li>
</ol>
</div>
<div class="section" id="the-rabbit-consumer-scout-chart">
<span id="how-it-works2-producescoutchart"></span><h2>The Rabbit Consumer Scout Chart<a class="headerlink" href="#the-rabbit-consumer-scout-chart" title="Permalink to this headline">#</a></h2>
<p>The RabbitConsumerScoutChart searches an IP address to see if there is a
compatible RabbitMQ consumer running on it.  The RabbitConsumerScoutChart was
designed to:</p>
<ul class="simple">
<li><p>be created/started/destroyed within another statechart</p></li>
<li><p>run in parallel with other instances of itself (to speed up searches of large LANs)</p></li>
<li><p>ensure that the RabbitMQ credentials were not in the code base</p></li>
<li><p>ensure that the encryption secrets where not in the code base</p></li>
<li><p>hide the complexity of the pika producer’s creation process</p></li>
<li><p>provide the capability to be run many times with different search criterion</p></li>
<li><p>provide it’s answers in the form of asynchronous events to which other
statecharts can subscribe.</p></li>
<li><p>be easy to debug/document</p></li>
</ul>
<p>The RabbitConsumerScoutChart is built by
<a class="reference internal" href="#how-it-works2-manual-netword-chart"><span class="std std-ref">ManNetChart</span></a> and the
<a class="reference internal" href="#how-it-works2-the-lanreccechart"><span class="std std-ref">LanRecceChart</span></a> objects:</p>
<a class="reference external image-reference" href="_static/small_context_rabbit_consumer_scout_chart.pdf"><img alt="_images/small_context_rabbit_consumer_scout_chart.svg" class="noscale-center" src="_images/small_context_rabbit_consumer_scout_chart.svg" /></a>
<p>From a high level, the RabbitConsumerScoutChart sends a message after it has
been constructed with the required RabbitMQ credentials.  It’s search can also
be refactored with the REFACTOR_SEARCH event:</p>
<a class="reference external image-reference" href="_static/medium_context_rabbit_consumer_scout_chart.pdf"><img alt="_images/medium_context_rabbit_consumer_scout_chart.svg" class="noscale-center" src="_images/medium_context_rabbit_consumer_scout_chart.svg" /></a>
<p>To perform a scouting mission for a given IP address, you will need the
routing_key and an exchange_name that you want to connect to, then do something
like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scout1</span> <span class="o">=</span> <span class="n">RabbitConsumerScoutChart</span><span class="p">(</span>
  <span class="s1">&#39;192.168.1.77&#39;</span><span class="p">,</span>
  <span class="n">routing_key</span><span class="o">=</span><span class="s1">&#39;heya.man&#39;</span><span class="p">,</span>
  <span class="n">exchange</span><span class="o">=</span><span class="s1">&#39;miros.mesh.exchange&#39;</span><span class="p">,</span>
  <span class="n">live_trace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># to debug the chart</span>
</pre></div>
</div>
<p>The above call would construct a statechart, start it and scout the network with
the provided information.</p>
<p>Upon completing it’s scouting mission, the <code class="docutils literal notranslate"><span class="pre">scout1</span></code> object would answer in
the form of an asynchronous event named <code class="docutils literal notranslate"><span class="pre">AMQP_CONSUMER_CHECK</span></code>.  The answer
will be in the payload of the event in the form of a namedtuple:</p>
<p><code class="docutils literal notranslate"><span class="pre">AMQPConsumerCheckPayload(ip_address,</span> <span class="pre">result,</span> <span class="pre">routing_key,</span> <span class="pre">exchange_name)</span></code>:</p>
<p>To get access to this answer within the statechart initiating the search, it
would have to be subscribed to the event (usually done in the entry condition of
the outer state):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">chart</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">Event</span><span class="p">(</span><span class="n">signals</span><span class="o">.</span><span class="n">AMQP_CONSUMER_CHECK</span><span class="p">))</span>
</pre></div>
</div>
<p>For the subscribing state machine to extract the answer it would need to react
to the <code class="docutils literal notranslate"><span class="pre">AMQP_CONSUMER_CHECK</span></code> event. Here is how you would do that within a
miros Factory object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The callback used to see the event</span>
<span class="k">def</span> <span class="nf">callback_AMQP_CONSUMER_CHECK</span><span class="p">(</span><span class="n">lan</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
  <span class="n">status</span> <span class="o">=</span> <span class="n">return_status</span><span class="o">.</span><span class="n">HANDLED</span>
  <span class="n">ip</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">ip_address</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">result</span>
  <span class="n">routing_key</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">routing_key</span>
  <span class="n">exchange_name</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">exchange_name</span>

  <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;AMQP consumer at searched location&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;AMQP consumer NOT at searched location&quot;</span><span class="p">)</span>


<span class="c1"># linking a state to an event and it&#39;s callback</span>
<span class="n">some_state</span> <span class="o">=</span> <span class="n">recce</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="s1">&#39;some_state&#39;</span><span class="p">)</span><span class="o">.</span> \
  <span class="n">catch</span><span class="p">(</span><span class="n">signals</span><span class="o">.</span><span class="n">AMQP_CONSUMER_CHECK</span><span class="p">,</span>
        <span class="n">handler</span><span class="o">=</span><span class="n">recce_rabbit_consumers_AMQP_CONSUMER_CHECK</span><span class="p">)</span><span class="o">.</span> \
  <span class="n">to_method</span><span class="p">()</span>
</pre></div>
</div>
<p>To perform another search on the same <code class="docutils literal notranslate"><span class="pre">scout1</span></code> object, post a <code class="docutils literal notranslate"><span class="pre">REFACTOR_SEARCH</span></code> event to it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scout1</span><span class="o">.</span><span class="n">postfifo</span><span class="p">(</span>
  <span class="n">Event</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signals</span><span class="o">.</span><span class="n">REFACTOR_SEARCH</span><span class="p">,</span>
    <span class="n">payload</span><span class="o">=</span><span class="p">{</span>
      <span class="s1">&#39;ip_address&#39;</span><span class="p">:</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">1.77</span><span class="p">,</span>
      <span class="s1">&#39;routing_key&#39;</span><span class="p">:</span> <span class="s1">&#39;archer.bob&#39;</span>
      <span class="s1">&#39;exchange_name&#39;</span><span class="p">:</span> <span class="s1">&#39;miros.mesh.exchange&#39;</span><span class="p">,</span>
      <span class="p">}</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>Here is the design diagram from the RabbitConsumerScoutChart, if you can’t see
it, click on it to download a pdf of the diagram:</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_consumer_scout_chart.pdf"><img alt="_images/miros_rabbitmq_consumer_scout_chart.svg" class="scale-to-fit" src="_images/miros_rabbitmq_consumer_scout_chart.svg" /></a>
<p>The <code class="docutils literal notranslate"><span class="pre">RabbitConsumerScout</span></code> class contains the data and methods that are used by
the <code class="docutils literal notranslate"><span class="pre">RabbitConsumerScoutChart</span></code>.  The <code class="docutils literal notranslate"><span class="pre">RabbitConsumerScout</span></code> class basically
hides the complexity of building a RabbitMQ producer by asking the
<code class="docutils literal notranslate"><span class="pre">RabbitTopicPublisherMaker</span></code> object to make the producer for it.  This
<code class="docutils literal notranslate"><span class="pre">RabbitTopicPublisherMaker</span></code> object, accesses the hidden credentials from the
<code class="docutils literal notranslate"><span class="pre">.env</span></code> file tucked away somewhere in an outer directory.  The diagram tries to
describe how this information is stored in an <code class="docutils literal notranslate"><span class="pre">.env</span></code> file, loaded into the
environment then used by the <code class="docutils literal notranslate"><span class="pre">RabbitTopidPublisherMaker</span></code> class to build up a
topic publisher.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">RabbitConsumerScoutChart</span></code> inherits from the <code class="docutils literal notranslate"><span class="pre">RabbitConsumerScout</span></code>
class, so it gets the publisher as part of the deal.  The client basically needs
to provide it an IP address, a routing key and an exchange name and it is ready
to perform a search.  A user can provide the <code class="docutils literal notranslate"><span class="pre">live_trace</span></code> and <code class="docutils literal notranslate"><span class="pre">live_spy</span></code>
arguments if they need to debug the statechart encased within the
<code class="docutils literal notranslate"><span class="pre">RabbitConsumerScoutChart</span></code>, but by default this instrumentation is off.  Let’s
turn this instrumentation on and then describe what it is doing.  We will search
for an address that doesn’t have a RabbitMQ server running on it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scout1</span> <span class="o">=</span> <span class="n">RabbitConsumerScoutChart</span><span class="p">(</span>
  <span class="s1">&#39;192.168.1.77&#39;</span><span class="p">,</span>
  <span class="n">routing_key</span><span class="o">=</span><span class="s1">&#39;heya.man&#39;</span><span class="p">,</span>
  <span class="n">exchange</span><span class="o">=</span><span class="s1">&#39;miros.mesh.exchange&#39;</span><span class="p">,</span>
  <span class="n">live_trace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># to debug the chart</span>
</pre></div>
</div>
<p>This will result in the following trace instrumentation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">2018</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">25</span> <span class="mi">18</span><span class="p">:</span><span class="mi">50</span><span class="p">:</span><span class="mf">34.888810</span><span class="p">]</span> <span class="p">[</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">1.77</span><span class="p">]</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">start_at</span><span class="p">()</span> <span class="n">top</span><span class="o">-&gt;</span><span class="n">producer_thread_engaged</span>
<span class="p">[</span><span class="mi">2018</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">25</span> <span class="mi">18</span><span class="p">:</span><span class="mi">50</span><span class="p">:</span><span class="mf">34.990279</span><span class="p">]</span> <span class="p">[</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">1.77</span><span class="p">]</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">try_to_connect_to_consumer</span><span class="p">()</span> <span class="n">producer_thread_engaged</span><span class="o">-&gt;</span><span class="n">producer_post_and_wait</span>
<span class="p">[</span><span class="mi">2018</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">25</span> <span class="mi">18</span><span class="p">:</span><span class="mi">50</span><span class="p">:</span><span class="mf">35.569538</span><span class="p">]</span> <span class="p">[</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">1.77</span><span class="p">]</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">consumer_test_complete</span><span class="p">()</span> <span class="n">producer_post_and_wait</span><span class="o">-&gt;</span><span class="n">no_amqp_consumer_server_found</span>
<span class="n">AMQPConsumerCheckPayload</span><span class="p">(</span><span class="n">ip_address</span><span class="o">=</span><span class="s1">&#39;192.168.1.77&#39;</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s1">&#39;heya.man&#39;</span><span class="p">,</span> <span class="n">exchange_name</span><span class="o">=</span><span class="s1">&#39;miros.mesh.exchange&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To see what is going on, compare the above trace to the state machine in this diagram:</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_consumer_scout_chart.pdf"><img alt="_images/miros_rabbitmq_consumer_scout_chart.svg" class="scale-to-fit" src="_images/miros_rabbitmq_consumer_scout_chart.svg" /></a>
<p>Here we will turn the trace into a sequence diagram, then explain what happens
during each event:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Statechart</span><span class="p">:</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">1.77</span><span class="p">]</span>
               <span class="n">top</span>   <span class="n">producer_thread_engaged</span>          <span class="n">producer_post_and_wait</span>    <span class="n">no_amqp_consumer_server_found</span>
                <span class="o">+--</span><span class="n">start_at</span><span class="p">()</span><span class="o">--&gt;|</span>                                <span class="o">|</span>                             <span class="o">|</span>
                <span class="o">|</span>     <span class="p">(</span><span class="mi">1</span><span class="p">)</span>       <span class="o">|</span>                                <span class="o">|</span>                             <span class="o">|</span>
                <span class="o">|</span>               <span class="o">+--</span><span class="n">try_to_connect_to_consumer</span><span class="p">()</span><span class="o">-&gt;|</span>                             <span class="o">|</span>
                <span class="o">|</span>               <span class="o">|</span>              <span class="p">(</span><span class="mi">2</span><span class="p">)</span>               <span class="o">|</span>                             <span class="o">|</span>
                <span class="o">|</span>               <span class="o">|</span>                                <span class="o">+--</span><span class="n">consumer_test_complete</span><span class="p">()</span><span class="o">--&gt;|</span>
                <span class="o">|</span>               <span class="o">|</span>                                <span class="o">|</span>            <span class="p">(</span><span class="mi">3</span><span class="p">)</span>              <span class="o">|</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="n">AMQPConsumerCheckPayload</span><span class="p">(</span>
    <span class="n">ip_address</span><span class="o">=</span><span class="s1">&#39;192.168.1.69&#39;</span><span class="p">,</span>
    <span class="n">result</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
    <span class="n">routing_key</span><span class="o">=</span><span class="s1">&#39;heya.man&#39;</span><span class="p">,</span>
    <span class="n">exchange_name</span><span class="o">=</span><span class="s1">&#39;miros.mesh.exchange&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic">
<li><p>We see that when the state machine starts, it initializes itself into the
<code class="docutils literal notranslate"><span class="pre">search</span></code> state which builds a <code class="docutils literal notranslate"><span class="pre">scout.producer</span></code> object and subscribes the
machine with the global <code class="docutils literal notranslate"><span class="pre">REFACTOR_SEARCH</span></code> event.  Upon completing these
tasks the <code class="docutils literal notranslate"><span class="pre">search</span></code> state is issued the <code class="docutils literal notranslate"><span class="pre">INIT_SIGNAL</span></code> which causes the
state machine to enter the <code class="docutils literal notranslate"><span class="pre">producer_thread_engaged</span></code> state.  Upon entering
this state the <code class="docutils literal notranslate"><span class="pre">scout.produer</span></code>’s thread is started and a delayed one-shot
<code class="docutils literal notranslate"><span class="pre">try_to_connect_to_consumer</span></code> event is built, then started.  This
one-shot is intended to give the <code class="docutils literal notranslate"><span class="pre">scout.producer</span></code> thread enough time to
turn itself on before we start using it.</p></li>
<li><p>About 200 ms after step 1, the <code class="docutils literal notranslate"><span class="pre">try_to_connect_to_consumer</span></code>
one-shot event causes a transition out of the <code class="docutils literal notranslate"><span class="pre">producer_thread_engaged</span></code>
state into the <code class="docutils literal notranslate"><span class="pre">producer_post_and_wait</span></code> state.  Upon entering the
<code class="docutils literal notranslate"><span class="pre">producer_post_and_wait</span></code> state, the state machine sends a test message out
to any consumer that might exist on the IP address being searched.  There is
a lot happening in the background; the message is setup as a random string
of character, it’s encrypted and serialized by the <code class="docutils literal notranslate"><span class="pre">scout.producer</span></code>, it’s
routing key and exchange information and RabbitMQ credentials are stamped
onto it.  This is really of no concern to the state machine, all of this
work is being done within the <code class="docutils literal notranslate"><span class="pre">scout.producer</span></code> object.</p>
<p>Once the message is sent the <code class="docutils literal notranslate"><span class="pre">producer_post_and_wait</span></code> state arms a
<code class="docutils literal notranslate"><span class="pre">consumer_test_complete</span></code> one-shot to fire in 500 ms.  This means that the
consumer, if it exists has half a second to respond to our search otherwise
the state machine will conclude that it is not there.</p>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">consumer_test_complete</span></code> event is fired roughly 500 ms after the end
of step 2.  This causes a call to the signal hygiene <code class="docutils literal notranslate"><span class="pre">cancel_events</span></code> method,
then the state machine checks the results of the producer’s search by looking at
it’s <code class="docutils literal notranslate"><span class="pre">scout.producer.connect_error</span></code> flag.  In this case no connection was
made so the flag is set to True.  This causes a transition into the
<code class="docutils literal notranslate"><span class="pre">no_amqp_consumer_server_found</span></code> state.  Upon entering the state the public
event <code class="docutils literal notranslate"><span class="pre">AMQP_CONSUMER_CHECK</span></code> is made with a four element tuple result:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s1">&#39;192.168.1.77&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="s1">&#39;heya.man&#39;</span><span class="p">,</span> <span class="s1">&#39;miros.mesh.exchange&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Some other statechart that has subscribed to the <code class="docutils literal notranslate"><span class="pre">AMQP_CONSUMER_CHECK</span></code>
will catch this event and determine that the address 192.168.1.77 will not
respond to the RabbitMQ credentials, the encryption key with the current
topic key and exchange name.</p></li>
</ol>
</div>
<div class="section" id="the-cache-file-chart">
<span id="cfc"></span><h2>The Cache File Chart<a class="headerlink" href="#the-cache-file-chart" title="Permalink to this headline">#</a></h2>
<p>The CacheFileChart is used to read and write the network discovery cache
information.  It was designed to:</p>
<ul class="simple">
<li><p>be created/started/destroyed within another statechart</p></li>
<li><p>allow one cache file to be readable and writable from thousands of different
programs running at the same time.</p></li>
<li><p>hide the complexity of concurrent file reads from the user</p></li>
<li><p>hide the complexity of concurrent file writes from the user</p></li>
<li><p>have a stochastic-exponential-timeout mechanism for pending read/write waits</p></li>
<li><p>Write a file based on an asynchronous event published from another statechart</p></li>
<li><p>Convert a file read into an asynchronous event which can be subscribed to
by another statechart</p></li>
<li><p>be easy to debug/document</p></li>
<li><p>run even if the json file doesn’t exist or is empty</p></li>
</ul>
<p>The network discovery process is expensive, so we will cache its results to a
JSON file.</p>
<p>The cache will persist beyond the life of the program that wrote it.  When the
next program runs, it will read the cache, determine if it is young enough to be
useful, and if so, it will skip the expensive network discovery process.</p>
<p>We use the JSON format since we will be transmitting this cache to other hosts
and JSON has become the standard format for transmitting data.</p>
<p>There could be thousands of processes trying to read and write to this cache
file at the same time.  To address this concern, we wrap this file access into
an active object which will check if the file is writable before trying to read
from it or write to it.  If the file is writable, the statechart will determine
that no other program is using the file.  The statechart that manages this file
access is called the CacheFileChart.</p>
<p>The CacheFileChart is build by the
<a class="reference internal" href="#how-it-works2-manual-netword-chart"><span class="std std-ref">ManNetChart</span></a> and the
<a class="reference internal" href="#how-it-works2-mirosrabbitlanchart"><span class="std std-ref">LanChart</span></a>.</p>
<a class="reference external image-reference" href="_static/small_context_cache_file_chart.pdf"><img alt="_images/small_context_cache_file_chart.svg" class="noscale-center" src="_images/small_context_cache_file_chart.svg" /></a>
<p>From a high level, the CacheFileChart responds to three messages and delivers
one:</p>
<a class="reference external image-reference" href="_static/medium_context_cache_file_chart.pdf"><img alt="_images/medium_context_cache_file_chart.svg" class="scale-to-fit" src="_images/medium_context_cache_file_chart.svg" /></a>
<p>The architectural diagram for the CacheFileChart is here:</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_cache_file_chart.pdf"><img alt="_images/miros_rabbitmq_cache_file_chart.svg" class="scale-to-fit" src="_images/miros_rabbitmq_cache_file_chart.svg" /></a>
<p>To construct the <code class="docutils literal notranslate"><span class="pre">CacheFileChart</span></code> with a live trace, for debugging:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cache_file</span> <span class="o">=</span> <span class="n">CacheFileChart</span><span class="p">(</span><span class="n">live_trace</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">default_json</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To read the file, subscribe to the <code class="docutils literal notranslate"><span class="pre">CACHE</span></code> event, then publish a
<code class="docutils literal notranslate"><span class="pre">CACHE_FILE_READ</span></code> event to the active fabric and wait for a <code class="docutils literal notranslate"><span class="pre">CACHE</span></code> event to
come back.  This <code class="docutils literal notranslate"><span class="pre">CACHE</span></code> event will contain a dictionary version of the JSON
cache file.</p>
<p>Here is a bit about how it works:</p>
<p>The design was intended to be built within another statechart and to start
itself upon being constructed.  The CacheFileChart subscribes to the
<code class="docutils literal notranslate"><span class="pre">CACHE_FILE_WRITE</span></code> and the <code class="docutils literal notranslate"><span class="pre">CACHE_FILE_READ</span></code> events.  If any other part of the
program wants to see what is in the cache, they would post a <code class="docutils literal notranslate"><span class="pre">CACHE_FILE_READ</span></code>.
The CacheFileChart will send a <code class="docutils literal notranslate"><span class="pre">CACHE</span></code> event with the contents of the cache and
whether the cache has been expired.</p>
<p>If any other statechart would like to write the cache, they would place the
contents of the write into a dict as the payload of the <code class="docutils literal notranslate"><span class="pre">CACHE_FILE_WRITE</span></code>.</p>
<p>Internally the <code class="docutils literal notranslate"><span class="pre">CACHE_FILE_READ</span></code> and <code class="docutils literal notranslate"><span class="pre">CACHE_FILE_WRITE</span></code> public events are turned
into the <code class="docutils literal notranslate"><span class="pre">file_read</span></code> and <code class="docutils literal notranslate"><span class="pre">file_write</span></code> events.  When the state chart sees that such
an event is posted it will try to enter the file_read or file_write states.
Such transitions can be blocked if the file is not writable (set by the OS).  In
the case that the event is blocked, the statechart re-posts the same event to
itself at a future time, then stops running.  The re-posting time is a random
number between 0.001 and a timeout.  This timeout parameter increases for each
re-posting failure, to a maximum value of 5 seconds.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">file_read</span></code> or <code class="docutils literal notranslate"><span class="pre">file_write</span></code> event succeeds to transition past the file access
state, it will lock the file by making it un-writable.  This global state, put
onto the file by the operating system will make the file exclusive to this
program.  When the file is read or written, the CacheFileChart will post either
a read_successful or write_successful event to itself.  This will cause an exit
signal to occur on the file_accessed state, which will make the file writable.
Other programs will now have the ability to access the same file when their
deferred <code class="docutils literal notranslate"><span class="pre">file_read</span></code> or <code class="docutils literal notranslate"><span class="pre">file_write</span></code> events fire.</p>
<p>The internal code within the file_read and file_write states was taken from
various stack overflow articles describing how to safely read and write a file
in a very short period of time, in an environment where many other programs are
trying to do the same thing.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The CacheFileChart was designed to work within the limited POSIX file features
offered by the Windows Linux Subsystem.  So, it should run on Windows, Linux
and the various Apple operating systems.</p>
</div>
</div>
<div class="section" id="manual-network-chart">
<span id="how-it-works2-manual-netword-chart"></span><h2>Manual Network Chart<a class="headerlink" href="#manual-network-chart" title="Permalink to this headline">#</a></h2>
<p>The ManNetChart lets a user to specify the addresses they
want to use in their network. It was designed to:</p>
<ul class="simple">
<li><p>Reference a simple JSON file for it’s information</p></li>
<li><p>By default this file is called <code class="docutils literal notranslate"><span class="pre">.miros_rabbitmq_hosts.json</span></code>, but this can be
overridden by setting a path in the ManNetChart constructor.</p></li>
<li><p>This JSON file will contain host information in the form of an IP address or
as a standard URL (not the complicated AMQP URL)</p></li>
<li><p>Test all manual addresses prior delivering them to the ProducerFactoryChart.</p></li>
<li><p>Re-evaluate the hosts file to see if any connections that were listed that
didn’t work, are working.</p></li>
</ul>
<p>The ManNetChart is built by the <a class="reference internal" href="#how-it-works2-the-producer-factory-chart"><span class="std std-ref">ProducerFactoryChart</span></a>.  The ManNetChart makes one
<a class="reference internal" href="#cfc"><span class="std std-ref">CacheFileChart</span></a> object and many different <a class="reference internal" href="#how-it-works2-producescoutchart"><span class="std std-ref">RabbitConsumerScoutChart</span></a> objects:</p>
<a class="reference external image-reference" href="_static/small_context_man_net_chart.pdf"><img alt="_images/small_context_man_net_chart.svg" class="noscale-center" src="_images/small_context_man_net_chart.svg" /></a>
<p>The ManNetChart subscribes to 3 events and publishes 2 events.</p>
<a class="reference external image-reference" href="_static/medium_context_man_net_chart.pdf"><img alt="_images/medium_context_man_net_chart.svg" class="scale-to-fit" src="_images/medium_context_man_net_chart.svg" /></a>
<p>The file that the <code class="docutils literal notranslate"><span class="pre">ManNetChart</span></code> uses defaults to
<code class="docutils literal notranslate"><span class="pre">.miros_rabbitmq_hosts.json</span></code>.  It is just a JSON file listing the hosts that
you want in your networks:</p>
<div class="highlight-JSON notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;hosts&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="s2">&quot;192.168.1.75&quot;</span><span class="p">,</span>
    <span class="s2">&quot;www.my_host_as_a_url.com&quot;</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You would specify the path to the file in the constructor, along with the mesh
routing key, the mesh exchange name and, if you want instrumentation turned on:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">man_net_chart</span> <span class="o">=</span> <span class="n">ManNetChart</span><span class="p">(</span>
  <span class="n">routing_key</span><span class="o">=</span><span class="s2">&quot;heya.man&quot;</span><span class="p">,</span>
  <span class="n">exchange_name</span><span class="o">=</span><span class="s2">&quot;sex_change&quot;</span><span class="p">,</span>
  <span class="n">cache_file_path</span><span class="o">=</span><span class="s2">&quot;.miros_rabbitmq_hosts.json&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The cache_file_path is an optional parameter, if you don’t set it, it will
default to using the .miros_rabbitmq_cache_file_chart in the current directory.
Likewise the <code class="docutils literal notranslate"><span class="pre">live_trace</span></code> and <code class="docutils literal notranslate"><span class="pre">live_spy</span></code> are default parameters, they default
to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>The ManNetChart architectural diagram can be seen here:</p>
<a class="reference external image-reference" href="_static/miros_rabbitmq_manual_discovery.pdf"><img alt="_images/miros_rabbitmq_manual_discovery.svg" class="scale-to-fit" src="_images/miros_rabbitmq_manual_discovery.svg" /></a>
<p>The <code class="docutils literal notranslate"><span class="pre">MirosRabbitManualNetwork</span></code> class inherits from the miros <code class="docutils literal notranslate"><span class="pre">Factory</span></code>
class, so it has the event processor and all of the other required state chart
features provided by the miros library.  It also contains all of the worker
functions and useful attribute names that are needed by the <code class="docutils literal notranslate"><span class="pre">ManNetChart</span></code>
class.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">ManNetChart</span></code> is created it immediately starts in the
<code class="docutils literal notranslate"><span class="pre">read_and_evaluate_network_details</span></code> state.  It subscribes to the
<code class="docutils literal notranslate"><span class="pre">AMQP_CONSUMER_CHECK</span></code> event.  It constructs a
<code class="docutils literal notranslate"><span class="pre">CacheFileChart</span></code>, subscribes to this chart’s <code class="docutils literal notranslate"><span class="pre">CACHE</span></code> event then publishes a
<code class="docutils literal notranslate"><span class="pre">CACHE_FILE_READ</span></code> to it and stops processing.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">CACHE</span></code> event is heard, if the <code class="docutils literal notranslate"><span class="pre">CACHE</span></code> event contains a file name
that matches to one provided to the <code class="docutils literal notranslate"><span class="pre">ManNetChart</span></code> constructor, it assigns it
to the hosts attribute and transitions to the <code class="docutils literal notranslate"><span class="pre">evaluate_network</span></code> state.</p>
<p>Upon entering the <code class="docutils literal notranslate"><span class="pre">evaluate_network</span></code> state, a RecceNode named tuple is made
for each host address that was listed in the hosts file.  Within this RecceNode
named tuple is a <a class="reference internal" href="#how-it-works2-producescoutchart"><span class="std std-ref">RabbitConsumerScoutChart</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">RabbitConsumerScoutChart</span></code> will start itself and determine if the address
provided to it has another miros-rabbitmq program running on it with the same
encryption keys and RabbitMQ credentials.  It finishes it search by sending out
the <code class="docutils literal notranslate"><span class="pre">AMQP_CONSUMER_CHECK</span></code> event with the results in its payload.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AMQP_CONSUMER_CHECK</span></code> could be coming at this chart from another part of
the system, so we confirm that its results are something that we care about then
process it:</p>
<ul class="simple">
<li><p>setting the scout attribute of the RecceNode named tuple to None so that the
Python garbage collector will remove the <code class="docutils literal notranslate"><span class="pre">RabbitConsumerScoutChart</span></code> that was
used to conduct the search</p></li>
<li><p>assigning the <code class="docutils literal notranslate"><span class="pre">live_hosts</span></code>, <code class="docutils literal notranslate"><span class="pre">list_amqp_urls</span></code>, <code class="docutils literal notranslate"><span class="pre">dead_hosts</span></code> and
<code class="docutils literal notranslate"><span class="pre">dead_amqp_urls</span></code> attributes.</p></li>
<li><p>determining if our search is complete by looking at the <code class="docutils literal notranslate"><span class="pre">searched</span></code> attribute all
of our candidate RecceNodes.</p></li>
</ul>
<p>If the search is complete, we post a <code class="docutils literal notranslate"><span class="pre">network_evaluated</span></code> event, which is
caught by a hook in the outer state.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">network_evaluated</span></code> hooks publishes the <code class="docutils literal notranslate"><span class="pre">CONNECTION_DISCOVERY</span></code> event
with the <code class="docutils literal notranslate"><span class="pre">live_hosts</span></code> and the <code class="docutils literal notranslate"><span class="pre">live_amqp_urls</span></code> tabulated during the
<code class="docutils literal notranslate"><span class="pre">evaluate_network</span></code>.</p>
<p>Notice that the <code class="docutils literal notranslate"><span class="pre">ManNetChart</span></code> stays in the <code class="docutils literal notranslate"><span class="pre">evaluate_network</span></code> state upon
completing a search.  If another search is required, the <code class="docutils literal notranslate"><span class="pre">EVALUATE_HOSTS_FILE</span></code>
event can be sent to the chart.  It might makes sense to send such an event
periodically if you would like to see if any of the dead hosts have become
responsive.</p>
</div>
</div>


        
        <div class="main-content__right-sidebar">
          <h2 class="sidebar-heading">On this page:</h2>
        </div>
      </div>
    </main>

    <div class="footer-wrapper">
      
      <footer class="main-footer main-footer--sidebar">
      
        <div class="relational-links">
          <div>
            
            ← <a class="relational-link" href="quick_start.html" title="previous chapter">Quick Start</a>
            
          </div>
          <div>
            
             <a class="relational-link" href="example.html" title="next chapter">Example</a> →
            
          </div>
        </div>
        
        <div class="copyright">
          © Copyright <span class="js-year"></span>,
          
          <a href="https://github.com/aleph2c" class="copyright_link">Scott Volk</a>.
          
        </div>
        
        
        <div class="last-updated">
          <span class="prefix">Last updated:</span>
          <span class="time">Jul 12, 2020 10:29 PM</span>
        </div>
        
        
        <div class="created-with">
          Created using <a href="http://sphinx-doc.org/" class="copyright_link">Sphinx</a> 3.1.2 with <span class="theme">13ds_theme_one</span>.
        </div>
        
      </footer>
    </div>
  </body>
</html>